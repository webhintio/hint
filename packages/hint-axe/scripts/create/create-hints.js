const { categoryId, escapeKey, isRuleDisabled, rulesIn, writeFile } = require('./utils');

/** @typedef {import('./utils').RuleMeta} RuleMeta */

/**
 * @param {string} category
 * @param {RuleMeta[]} rules
 */
const createHint = async (category, rules) => {
    const id = categoryId(category);

    const ruleIds = rules.map((rule) => {
        return `'${rule.id}'`;
    }).join(', ');

    const disabledRules = rules.filter(isRuleDisabled);
    const disabledIds = disabledRules.map((rule) => {
        return `'${rule.id}'`;
    }).join(', ');

    if (ruleIds.length === disabledIds.length) {
        console.warn('All rules are disabled for category: ', category);
    }

    const content = `// autogenerated by scripts/create/create-hints.js
import { HintContext } from 'hint/dist/src/lib/hint-context';
import { IHint } from 'hint/dist/src/lib/types';
import { register } from './util/axe';

import meta from './meta/${id}';

export default class AxeHint implements IHint {
    public static readonly meta = meta;
    public constructor(context: HintContext) {
        register(context, [${ruleIds}], [${disabledIds}]);
    }
}
`;

    await writeFile(`src/${id}.ts`, content);
};

/**
 * Generate a `*.ts` file containing the hint implementation for each
 * sub-hint. Then generate an `index.ts` file referencing the
 * implementations for all sub-hints.
 *
 * @param {string[]} categories
 * @param {RuleMeta[]} rules
 */
const createHints = async (categories, rules) => {
    for (const category of categories) {
        createHint(category, rulesIn(category, rules));
    }

    const hints = categories.map((category) => {
        const id = categoryId(category);

        return `    ${escapeKey(id)}: require('./${id}')`;
    });

    const content = `// autogenerated by scripts/create/create-hints.js
module.exports = {
${hints.join(',\n')}
};
`;

    await writeFile('src/index.ts', content);
};

module.exports = { createHints };
